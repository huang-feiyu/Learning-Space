# 设计模式

[Mermaid作图](https://blog.csdn.net/horsee/article/details/113883818)

[refactoring: design-patterns](https://refactoringguru.cn/design-patterns/catalog)

[设计模式：可复用面向对象软件的基础](F:\ProgramLanguage\DesignPattern\设计模式：可复用面向对象软件的基础_10455167.pdf)

[TOC]

## 概述

**设计模式**是软件设计中常见问题的典型解决方案。

**模式**

模式不是代码，而是解决特定问题的一般性概念。模式不是算法，而是对解决方案的更高层次描述，更像是蓝图。

模式的描述：

* 意图
* 动机
* 结构
* 不同语言实现

## 创建型模式

> **创建型模式**提供创建对象的机制，增加已有代码的灵活性和可复用性。

### 工厂方法模式

> Factory Method

* 意图：在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型

* 动机：调用工厂方法的代码 （通常被称为 *客户端* 代码） 无需了解不同子类返回实际对象之间的差别。 

* 结构：

  ![](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure-indexed-2x.png)

* 应用：

  1. 无法预知对象确切类别以及依赖关系
  2. 用户能够扩展软件库或框架的内部组件
  3. 复用现有对象 <font color=red><small>I can not understand</small></font>

### 抽象工厂模式

> Abstract Factory

* 意图：创建一系列对象，却不需要指定具体类

* 动机：客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

* 结构：

  ![image-20220203221936005](README.img/image-20220203221936005.png)

* 应用：

  1. 代码需要与多个不同系列的相关产品交互，但无法提前获取相关信息 或者 对未来扩展性的考虑
  2. 一个类基于一组抽象方法，且主要功能因此变得不明确

### 生成器模式

> Builder

* 意图：分步创建复杂对象，允许使用相同的创建代码生成不同类型和形式的对象

* 动机：客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果

* 结构：

  ![image-20220205212304489](README.img/image-20220205212304489.png)

* 应用：

  1. 避免重叠构造函数 (override constructor in Java)
  2. 使用代码创建不同形式的产品
  3. 构造组合树或其他复杂对象

### 原型模式

> Prototype, clone

* 意图：使能复制已有对象，而又无需使代码依赖它们所属的类

* 动机： 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象

* 结构：

  ![image-20220208221345861](README.img/image-20220208221345861.png)

* 应用：

  1. 需要复制一些对象，同时又希望代码独立于这些对象所属的具体类 (处理第三方代码通过接口传递的对象)
  2.   如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量

### 单例模式

> Singleton

* 意图：保证一个类只有一个实例， 并提供一个访问该实例的全局节点

* 动机：无论何时调用单例类的静态方法， 它总是会返回相同的对象

* 结构：

  ![image-20220208222640716](README.img/image-20220208222640716.png)

* 应用：

  1. 某个类只有一个可用实例
  2. 更加严格地控制全局变量

## 结构型模式

> **结构型模式**介绍如何将对象和类组装成较大的结构，同时保证结构的灵活和高效。

### 适配器模式

> Wrapper

* 意图：使接口不兼容的对象能够相互合作

* 动机：适配器模式通过封装对象将复杂的转换过程隐藏于幕后，转换接口促进对象之间合作

* 结构：

  ![image-20220211180449082](README.img/image-20220211180449082.png)

* 应用：

  1. 希望使用一个接口不兼容的类
  2. 复用兄弟类

### 桥接模式

> Bridge

* 意图：将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用

* 动机：桥接模式通过将继承改为组合的方式，抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为

* 结构：

  ![image-20220223212626688](README.img/image-20220223212626688.png)

* 应用：

  1. 拆分或者重组一个具有多重功能的庞杂类
  2. 在几个独立维度扩展一个类
  3. 运行时切换不同实现方法

### 组合模式

> Composite

* 意图：将对象组合成树状结构， 并且能像使用独立对象一样使用它们

* 动机：无需了解构成树状结构的对象的具体类，只需调用通用接口以相同的方式对其进行处理（如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。）

* 结构：

  ![image-20220223213307555](README.img/image-20220223213307555.png)

* 应用：

  1. 需要实现树状对象结构
  2. 希望 Client 使用相同方式处理简单和复杂元素

#### 装饰模式

> Decorator

* 意图：通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为

* 动机：只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象

* 结构：

  ![image-20220224085728297](README.img/image-20220224085728297.png)

* 应用：

  1. 无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为
  2. 如果用继承来扩展对象行为的方案难以实现或者根本不可行

### 外观模式

> Facade

* 意图：为程序库、 框架或其他复杂类提供一个简单的接口

* 动机：降低程序耦合性、复杂度；外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能

* 结构：

  ![image-20220224091252638](README.img/image-20220224091252638.png)

* 应用：

  1. 需要一个指向复杂子系统的直接接口， 且该接口的功能有限
  2. 需要将子系统组织为多层结构

### 享元模式

> Cache, Flyweight

* 意图：通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象

* 动机：同上

* 结构：

  ![image-20220224093949807](README.img/image-20220224093949807.png)

* 应用：

  1. 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式

### 代理模式

> Proxy

* 意图：代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理

* 动机：如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作

* 结构：

  ![image-20220224100411683](README.img/image-20220224100411683.png)

* 应用：

  1. 如果你有一个偶尔使用的重量级服务对象，延迟初始化（虚拟代理）
  2. 只希望特定客户端使用服务对象，访问控制（保护代理）
  3. 本地执行远程服务（远程代理）
  4. 记录日志请求（日志记录代理）
  5. 智能引用，在没有 Client 使用某个重量级对象时利己销毁该对象

## 行为模式

> **行为模式**负责对象间的高效沟通和职责委派。

